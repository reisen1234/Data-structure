# 二叉树基础
* (作为二叉树的入门题，没有什么难度，主要是搞明白递归在二叉树中的妙用)
---
## 二叉树无非只是一个结点连接着左节点和右结点，如果没有孩子结点那就是叶结点。
有几种特殊的二叉树可以了解一下
1. 完全二叉树：无非对树种结点从上到下从左到右进行编号，而堆这种数据结构就是完全二叉树
2. 满二叉树，结点要么是叶子结点，要么有两个子节点，没有单个的
---
## 二叉树如何实现
1. 数组法，我们假设一个数组存储了二叉树的所有结点，设父节点的编号是x，那么他的左孩子的编号就是 2 * x，右孩子就是 2 * x + 1， 很简单的吧。如果孩子结点为空，可以用特殊的数字或者符号代替（null），但是这种数组法实现的二叉树适用于完全二叉树，当然，你想普通二叉树也可以用数组法，不过一般情况下会造成空间浪费，类似于一个系数矩阵？
2. 链表法，这个实现二叉树就比较节省空间了，一般都是用这个。无非就是创建结点的时候，让他的父节点指向他，还得判断他是左孩子还是右孩子，可以思考下怎么实现（递归挺好的） 

---
## 二叉树的几种遍历
1. 先序遍历 ： 根左右，先遍历根再遍历左子树，右子树
2. 中序遍历 ： 左根右
3. 后序遍历 ： 左右根（以此类推，画一棵树去练一练）
---
## 需要我们实现的几个函数
1. int tree_depth(BTreeNode* root) 计算树的深度 <br>
 实现这个函数用递归就可以了，树的深度无非就是左右子树中比较大的那个，那我们就可以写一个递归式了 deep(root->left,root->right) + 1; 如果遇到空就返回。
 2. void destroy_tree(BTreeNode* root) 销毁树 <br>
  树的销毁肯定得从底部向上进行销毁，如果删了根节点，怎么销毁根节点以下的孩子？所以我们需要一个从下往上，最晚销毁根节点的方法，这不就是后序遍历吗？
3. 三种遍历，这是基础，就不说了，递归式遍历较为简便 